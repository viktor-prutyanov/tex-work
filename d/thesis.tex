\documentclass{mipt-thesis-bs}
\usepackage{listings}
\usepackage{biblatex}
\addbibresource{thesis.bib}
\title{Разработка методов отладки в реальном времени и отложенного анализа проблем в гостевой операционной системе Microsoft Windows под гипервизором QEMU/KVM}
\author{Прутьянов В.\,В.}
\supervisor{Каган Р.\,В.}
\groupnum{416}
\faculty{Факультет радиотехники и кибернетики}
\department{Кафедра теоретической и прикладной информатики}

\begin{document}
\pagenumbering{gobble}
\titlepage

\chapter*{Аннотация}
На данный момент рабочая нагрузка большинства серверов выполняется с использованием технологии виртуализации, одним из видов которой является гипервизорная виртуализация. Крайне популярным гипервизором, в том числе для запуска Windows, является гипервизор QEMU/KVM.

Зачастую во время работы гостевых ОС возникают проблемы, такие как аварийные завершения и зависания. Один из методов решения проблем, возникающих при работе ОС Windows, — снятие снимков состояния системы, называемых дампами, которые в случае виртуальной машины могут быть сделаны со стороны гипервизора, и их анализ с помощью отладчика WinDbg. Целью данной работы является создание метода анализа проблем Windows, работающей внутри виртуальной машины под управлением QEMU/KVM.

В работе рассмотрены существующие методы создания отладочных дампов Windows со стороны гипервизора и их недостатки. Исследована структура полного отладочного дампа Windows, представлен метод сбора данных для создания дампа, не зависящий от версии Windows, предложен новый метод передачи c помощью виртуального устройства VMCoreInfo необходимой  информации о гостевой ОС в гипервизор и создания с ее помощью полного дампа памяти Windows.

Представлена программная реализация этих методов в виде драйвера для гостевой Windows и компонента гипервизора QEMU, позволяющих со стороны гипервизора создавать отладочный дамп, который может быть проанализирован WinDbg, как во время работы системы, так и после аварийного завершения.

\pagenumbering{arabic}
\setcounter{page}{2}

\newpage
\tableofcontents
\pagestyle{plain}


\chapter{Введение}

В настоящее время большая часть рабочей серверной нагрузки выполняется с помощью различных технологий виртуализации\cite{server-trends}. Виртуализация позволяет на основе одной физической системы запускать множество независимых друг от друга изолированных сред, между которыми могут быть распределены вычислительные ресурсы физической системы.

Одним из видов виртуализации является гипервизорная виртуализация. В этом случае, специальное ПО, называемое гипервизором, который может быть как частью операционной системы, так и непосредственно выполняться на физическом оборудовании, позволяет разделить физические ресурсы между изолированными средами, которые называются виртуальными машинами\cite{t1}. Тогда физическое оборудование, на котором запущен гипервизор называется хостом, а виртуальные машины называются гостями.

Сейчас в качестве хостовой ОС на серверах часто используется ОС Linux. Один из компонентов этой системы -- гипервизор KVM (Kernel Virtual Machine), который работает в связке с эмулятором QEMU. Операционные системы, работающие внутри хоста и гостей, могут быть различными в случае гипервизорной виртуализации, поэтому внутри виртуальной машины под управлением QEMU/KVM может быть запущена почти любая ОС, в том числе Linux и Microsoft Windows.

Виртуализация, в частности гипервизорная, является достаточно сложной процедурой, поэтому при работе гостевой ОС могут возникать проблемы, такие как зависания или аварийные завершения. Эти проблемы могут быть вызваны как ошибками в работе гостевой ОС, так и ошибками, связанными с неправильной работой гипервизора. Их можно решать методами, разработанными для физических машин, но все они требуют специальной настройки ОС, что не всегда возможно сделать, а виртуализация позволяет этого избежать. Существуют два метода анализа подобных проблем: отладка ядра ОС и анализ снимков состояния ОС, называемых дампами.

Для гостевой Linux оба метода удобны и не представляют большой сложности при работе с QEMU:

\begin{itemize}
\item QEMU предоставляет интерфейс для отладчика GDB, через который можно отлаживать ядро гостевой ОС Linux как обычную программу\cite{qemu-gdb}.
\item QEMU позволяет сделать снимок состояния виртуальной машины, называемый дампом, в формате ELF, который затем можно анализировать утилитой crash.
\end{itemize}

Аналоги этих методов существуют и для случая, когда виртуальная машина работает под управлением Windows:

\begin{itemize}
\item Подключение через виртуальный последовательный порт или Ethernet отладчика WinDbg\cite{qemu-win}.
\item Создание отладочного дампа в формате DMP, понятном отладчику WinDbg, и его анализ.
\end{itemize}

Поскольку, как правило, администрируют хостовые системы и гостевые системы разные люди, наиболее предпочтительным для любой гостевой ОС является создание отладочных дампов, так как это требует наименьшее количество действий (или вовсе не требует) от пользователя виртуальной машины, который может не обладать соответствующей квалификацией или желанием для настройки гостевой ОС в режиме отладки\cite{windbgvm}. Также, метод создания и анализа отладочных дампов не требует специального воспроизведения условий, приводящих к ошибке. Таким образом, возможность снятия отладочных дампов имеет наибольшую ценность для разработчиков ПО виртуализации.

На данный момент метод, связанный с анализом дампов, в случае гостевой ОС Windows под управлением QEMU имеет существенные проблемы:

\begin{itemize}
\item QEMU не имеет встроенного средства для создания дампов памяти в формате DMP. Для получения дампа в этом формате в произвольный момент времени на живой системе можно попытаться создать дамп в формате ELF и конвертировать его в формат DMP, но это не всегда возможно, особенно на последних версиях Windows.
\item В случае аварийного завершения Windows автоматически сохраняет дамп на диске, что сопровождается так называемым BSoD (Blue Screen of Death -- синий экран смерти), но для этого, во-первых, система должна быть специальным образом настроена на создание полного дампа памяти\cite{dumphowto}, который наиболее полно отражает состояние системы (по умолчанию же сохраняется практически бесполезный малый дамп памяти), а во-вторых, дамп может быть не создан, например, если не хватает свободного места на диске, или по другим причинам\cite{nodump}.
\end{itemize}

Таким образом, одним из важных сценариев является создание дампа в момент возникновения BSoD, когда гостевая система по каким-либо причинам не способна это сделать. Поэтому представляется актуальным разработка метода создания отладочного дампа гостевой Windows в формате, понятном отладчику WinDbg, как в случае живой системы, так и на этапе аварийного завершения.

На данный момент выпущено много различных версии Windows, из которых сейчас действительно популярны серверные системы начиная с Windows Server 2008 R2 и десктопные системы начиная с Windows 7, которые работают на основе одного ядра Windows версии 6.1. Также, наиболее популярными сейчас являются 64-битные версии, поэтому в работе будут рассмотрены 64-битные версии Windows на основе этой и более новых версии ядра.

Целью данной работы является создание метода анализа аварийных завершений и зависаний Windows, работающей внутри виртуальной машины под управлением QEMU/KVM. Для этого требуется исследовать необходимые для создания отладочного дампа данные, а также придумать и программно реализовать метод создания дампов со стороны гипервизора.

Так как в различных версиях Windows определения структур данных ядра могут различаться\cite{kprcb}\cite{win10-struct}, хорошей чертой метода была бы независимость от версии Windows. Это бы означало использование более прозрачной логики и увеличивало бы шансы метода на корректную работу с новыми версиями Windows.

В настоящей работе рассмотрено, из чего состоит полный дамп памяти Windows, какие данные требуются для его создания, существующие методы их сбора и предложен подход для создания дампа во время BSoD, а также расширение этого подхода для работы на живой системе, описана реализация этих методов.

\chapter{Постановка задачи}

\begin{itemize}
\item Исследовать, какие данные необходимы для создания полного дампа памяти и как они могут быть получены.
\item Разработать метод снятия полных дампов памяти в формате DMP с 64-разрядной гостевой ОС Windows с версией ядра $\geqslant$ 6.1, работающей под управлением гипервизора QEMU/KVM, в момент аварийного завершения.
\item Добавить возможность снятия дампов с живой системы.
\item Программно реализовать эти методы.
\end{itemize}

\chapter{Основные используемые технологии и инструменты}

\section*{QEMU}

QEMU -- эмулятор аппаратного обеспечения с открытым исходным кодом, основанный на динамической трансляции. Позволяет эмулировать процессоры различных архитектур (x86, PowerPC, ARM и другие) на различных хостовых процессорах (x86, PowerPC, ARM, MIPS и другие). Поддерживает два режима: эмуляция полной системы, при которой на виртуальном процессоре запускается операционная система (такая как Windows или Linux), и эмуляция пользовательского режима Linux, которая позволяет запустить Linux-программу, собранную для процессора одной архитектуры, на процессоре другой архитектуры\cite{qemu-bellard}. В режиме системной эмуляции QEMU может эмулировать не только процессор, но и периферийные устройства, такие как сетевые карты и видеоадаптеры. В случае, когда архитектура хоста и целевая архитектура совпадают, часть кода может быть исполнена прямо на хостовом процессоре, но часть инструкций могут нарушить изоляцию виртуальной машины и должны быть эмулированы. В случае виртуализации x86-совместимого процессора на процессоре той же архитектуры, QEMU может использовать преимущества аппаратной виртуализации, при которой процессор, исполняя код, учитывает хостовый он или гостевой, упрощая таким образом задачу изоляции, и минимизируя долю кода, требующего эмуляции. Для этого требуется один из ускорителей (accelerators), такой как KVM, HAXM, Apple Hypervisor Framework или другой, кроме того, аппаратная виртуализация должна поддерживаться процессором\cite{qemu-ibm}.

\section*{KVM}

KVM (Kernel-based Virtual Machine) -- технология виртуализации, встроенная в ядро Linux\cite{kvm}. Состоит из загружаемого модуля ядра kvm.ko и модуля, специфичного для процессора -- kvm-intel.ko или kvm-amd.ko. Представляет из себя гипервизор второго типа -- специальный дополнительный программный слой поверх хостовой ОС, который управляет гостевыми ОС, а эмуляцию и управление оборудованием делегирует хостовой операционной системе\cite{t2}\cite{kvm1}.

Для исполнения кода гостевых ОС на хостовом процессоре KVM использует одну из технологий аппаратной поддержки виртуализации, например, Intel VT-x или AMD-V (в зависимости от производителя хостового процессора), производя обработку инструкций, которые непосредственно на процессоре выполниться не могут. Исполнение прерывается каждый раз при возникновении особого события в хостовом процессоре -- VMexit. Возникновение события VMexit означает, что инструкция, которая вызвала его появление, по какой-либо причине не может быть исполнена (например если это инструкция ввода-вывода или остановки процессора) на хостовом процессоре и должна быть обработана\cite{im}. В этом случае KVM либо самостоятельно производит эмуляцию, не тратя время на переключения контекста, либо возращает управление userspace-программе, которая управляет KVM через устройство \texttt{/dev/kvm}.

Технологии аппартной виртуализации Intel VT-x и AMD-V заключаются именно в возможности запуска изолированного гостевого кода и обработки особых ситуаций, возникающих во время его выполнения.

\begin{figure}[h]
\begin{center}
    \includegraphics[width=11cm]{qemukvm.png}
    \caption{QEMU/KVM}
    \label{fig:qemukvm}
\end{center}
\end{figure}

\section*{QEMU/KVM}

Одним из наиболее популярных вариантов, в том числе на корпоративном рынке, является связка QEMU/KVM, которая позволяет виртуальной машине достичь производительности, близкой к производительности хостовой машины.

В таком режиме работы QEMU через системный интерфейс \texttt{/dev/kvm} создает виртуальные машины и виртуальные процессоры (vCPU), а затем, через тот же интерфейс, передает управление KVM для исполнения кода гостевой системы, а получает управление назад, когда KVM прерывает исполнение гостевого кода\cite{qemu-kvm-arch}. В частности, QEMU занимается эмуляцией работы периферии\cite{qemu-devices}. После того как QEMU завершит обработку, работу vCPU можно возобновлять.

QEMU является обычным пользовательским приложением, запускающим один процесс для каждого виртуального процессора KVM. Работа такого процесса, как и остальных процессов системы, управляется обычным планировщиком процессов Linux\cite{qemu-kvm-arch}. Ниже приведен псевдокод процесса QEMU, использующего KVM для исполнения гостевого кода:

\begin{verbatim}
open("/dev/kvm")
ioctl(KVM_CREATE_VM)
ioctl(KVM_CREATE_VCPU)
for (;;) {
    ioctl(KVM_RUN)
    switch (exit_reason) {
    case KVM_EXIT_IO:  /* ... */
    case KVM_EXIT_HLT: /* ... */
    }
}
\end{verbatim}

\section*{WDK}

WDK (Windows Driver Kit) -- набор инструментов и библиотек для разработки драйверов под ОС Windows. В частности, включает в себя отладчики WinDbg и kd, а также утилиту dumpchk, которая предназначена для обнаружения ошибок в дампах аварийных завершений. Кроме того, набор содержит заголовочные файлы с описаниями некоторых структур ядра Windows.

\section*{WinDbg и kd}

WinDbg и kd -- отладчики от корпорации Microsoft, предназначенные для работы с пользовательским и системным кодом под ОС Windows. Оба эти инструмента содержат возможность анализа дампов аварийных завершений Windows. Данные отладчики позволяют использовать отладочную информацию для более удобного анализа дампа и определения причины аварийного завершения системы. Отладчики могут отобразить информацию из любой доступной отлаживаемой системе области вирутальной и физической памяти.

Кроме того, отладчики обладают такими возможностями как отображение содержимого регистров (\picref{fig:kdr}) и стека вызовов (\picref{fig:kdk}). Если для загруженных модулей доступна отладочная информация, то элементами стека вызовов будут не просто адреса, а названия функций.

\begin{figure}[h]
\begin{center}
    \includegraphics[width=1\textwidth]{r.png}
    \caption{kd.exe отображает регистры и текущую функцию}
    \label{fig:kdr}
\end{center}
\end{figure}

\begin{figure}[h]
\begin{center}
    \includegraphics[width=1\textwidth]{k.png}
    \caption{kd.exe отображает стек вызовов}
    \label{fig:kdk}
\end{center}
\end{figure}


\chapter{Структура отладочных дампов Windows}

В ОС Windows существует несколько различных форматов дампов, набор которых различается в зависимости от версии Windows\cite{dumps}. В данной работе рассматривается полный дамп памяти (complete memory dump), который доступен во всех рассматриваемых версиях Windows. Этот тип дампа содержит наибольшее количество информации и позволяет отладчику анализировать весь объем используемой системой физической памяти\cite{completedump}.

К сожалению, официальной спецификации формата DMP от компании Microsoft не существует. Наиболее полное описание структуры заголовка полного дампа может быть найдено в коде операционной системы Singularity (экспериментальная ОС с открытым исходным кодом от Microsoft)\cite{mssing}, хотя объяснения смысла полей нет и там.

Структура полного дампа (\picref{fig:dmp-scheme}) в упрощенном виде представляет из себя несколько крупных частей:

\begin{itemize}
    \item Заголовок длиной в одну страницу (4 килобайт) на 32-разрядной системе и длиной 2 страницы (8 килобайт) на 64-разрядной системе.
    \item Снимки непрерывных регионов физической памяти (Run 0 -- Run N). Их количество, начальные адреса и длины хранятся в заголовке.
\end{itemize}

\begin{figure}[h]
\begin{center}
    \includegraphics[width=5cm]{dmp_scheme1.png}
    \caption{Упрощенная cхема полного дампа}
    \label{fig:dmp-scheme}
\end{center}
\end{figure}

Информацию о сохраненной в файле дампа физической памяти может отображать утилита dumpchk.exe (\picref{fig:runs}), поставляющаяся вместе с отладчиком WinDbg. Как правило, регионов больше одного из-за так называемых PCI-окон (PCI-hole), поскольку часть физического адресного пространства используется для коммуникации с периферийными устройствами и не подходит сохранения данных. Таким образом, не все физическое адресное пространство сохраняется в файле дампа.

\begin{figure}[h]
\begin{center}
    \includegraphics[width=1\textwidth]{runs.png}
    \caption{Список регионов физической памяти отображается утилитой dumpchk.exe}
    \label{fig:runs}
\end{center}
\end{figure}

Каждый регион физической памяти описывается в заголовке дампа структурой {\_}PHYSICAL{\_}MEMORY{\_}RUN64, где хранится начало и длина региона:

\begin{verbatim}
struct _PHYSICAL_MEMORY_RUN64 {
    ULONG64 BasePage;
    ULONG64 PageCount;
}
\end{verbatim}

Кроме информации о регионах физической памяти, заголовок дампа содержит другие необходимые для работы отладчика поля, в том числе:

\begin{itemize}
    \item BugcheckData -- код ошибки и 4 параметра, которые описывают причину аварийного завершения (падения) системы. Их можно увидеть на синем экране во время падения (\picref{fig:bsod}). Отладчик WinDbg анализирует эти значения и выводит примерную причину падения (\picref{fig:windbg-analyze}).
    \item RequiredDumpSpace -- суммарный размер дампа в байтах.
    \item DirectoryTableBase -- физический адрес корня таблицы страниц, на основе которой отладчик будет производить страничное преобразование для доступа к данным по виртуальным адресам.
    \item PfnDatabase -- виртуальный адрес базы данных PFN-номеров\cite{winternals2}.
    \item PsLoadedModuleList -- виртуальный адрес списка загруженных исполняемых модулей.
    \item MinorVersion, MajorVersion -- два поля, вместе определяющие версию Windows.
    \item KdDebuggerDataBlock -- виртуальный адрес специальной структуры ядра Windows, хранящей необходимую для работы отладчика информацию.
\end{itemize}

\begin{figure}[h]
\begin{center}
    \includegraphics[width=1\textwidth]{dump.png}
    \caption{Фрагменты BSoD}
    \label{fig:bsod}
\end{center}
\end{figure}

\begin{figure}[h]
\begin{center}
    \captionsetup{justification=centering}
    \includegraphics{ss1.png}
		\caption{Фрагмент вывода команды \texttt{"!analyze -v"} WinDbg. Отладчик выводит причину падения.}
    \label{fig:windbg-analyze}
\end{center}
\end{figure}

\section*{KdDebuggerDataBlock}

Путем модификации полей заголовка и анализа модифицированного дампа выяснилось, что данных из заголовка недостаточно для правильной работы отладчика, поскольку некоторые поля заголовка ссылаются на структуры, сохраненные в самой памяти. Наиболее важная из таких структур -- KdDebuggerDataBlock, без адреса которой в заголовке анализ дампа практически невозможен отладчиком. Она содержит адреса других важных структуры данных ядра и смещения внутри них, например:
\begin{itemize}
\item KernBase -- виртуальный адрес загруженного в память образа ядра Windows (ntoskrnl.exe). WinDbg использует этот адрес для загрузки подходящих отладочной информации, которая затем позволяет преобразовывать имена отладочных символов в адреса.
\item KiProcessorBlock -- указатель на массив указателей на PRCB (processor control block) -- структуры, в которые ОС сохраняет данные по каждому используемому процессору\cite{winternals1}.
\item OffsetPrcbContext -- в соответствии с названием, смещение структуры внутри PRCB, в которую ОС сохраняет регистровый контекст при аварийном завершении.
\item OwnerTag -- сигнатура KdDebuggerDataBlock -- ASCII символы \texttt{"KDBG"}.
\end{itemize}
Следующие поля, содержащиеся в KdDebuggerDataBloсk, имеют аналоги в виде полей из заголовка полного дампа памяти.
\begin{itemize}
\item KiBugcheckData -- указатель на структуру с данными о падении, которые автоматически сохраняются в это поле системой во время аварийного завершения.
\item MmPfnDatabase -- указатель на базу данных PFN-номеров.
\item PsLoadedModuleList -- список загруженных модулей.
\end{itemize}

В отличие от заголовка дампа, структура содержимого KdDebuggerDataBlock описаны под названием {\_}KDDEBUGGER{\_}DATA64 в файле \texttt{wdbgexts.h}, который поставляется вместе с WinDbg. Эта структура обладает таким свойством, что с появлением новой версии Windows в ее конец только добавляются новые поля, а уже существующие остаются по тем же смещениям, на это можно полагаться независимо от версии Windows.

Можно заметить, что если такие поля заголовка как RequiredDumpSpace при определенных условиях можно вычислить и заполнить на основе данных из гипервизора, то такие поля как KdDebuggerDataBlock и PsLoadedModuleList известны только гостевой ОС.

Таким образом, для получения правильного дампа, нужно собрать вместе корректный заголовок и снимки непрерывных участков физической памяти. Снимки несложно сделать из QEMU, поскольку он имеет удобный доступ к физической памяти виртуальной машины. Получение же заголовка, как можно было понять из описания его полей, является нетривиальной задачей.

\chapter{Обзор существующих решений}

Поскольку проблема получения заголовка полного дампа памяти актуальна, попытки ее решения уже предпринимались. Поэтому рассмотрим несколько существующих решений и их недостатки.

\section*{Volatility}

Volatility -- набор программ с открытым исходным кодом для анализа памяти различных операционных систем. Содержит расширение под названием raw2dmp, которое позволяет конвертировать сырой (raw) снимок памяти Windows в формат, который может быть прочитан WinDbg.

Процедура получения дампа с использованием Volatility выглядит таким образом:
\begin{itemize}
    \item Cбор дампа в формате ELF с помощью QEMU.
    \item Конвертация в формат RAW, который содержит только физическую память виртуальной машины, расширением imagecopy.
    \item Преобразование в формат DMP c помощью расширения raw2dmp\cite{lpblog}.
\end{itemize}

Алгоритм работы расширения raw2dmp состоит в последовательном сканировании памяти и нахождении по сигнатуре структуры KdDebuggerDataBlock, который затем помогает создать корректный заголовок дампа.

На данный момент этот метод имеет следующие проблемы:

\begin{itemize}
    \item После конвертации raw-дамп не хранит в себе информации о содержимом регистров виртуальных процессоров, поэтому после преобразования в дамп для WinDbg, содержимое регистров будет взято отладчиком из сохраненного системой контекста и будет неактуальным. В частности, это помешает восстановлению стеков вызовов (\picref{fig:windbg-vol}).
    \item Начиная с Windows 8, система может на этапе загрузки зашифровать область памяти, в которой находится KdDebuggerDataBlock, поэтому его невозможно будет найти простым сканированием памяти и сравнением сигнатур.
\end{itemize}

\begin{figure}[h]
\begin{center}
    \captionsetup{justification=centering}
    \includegraphics[width=1\textwidth]{vol1.png}
    \caption{WinDbg ошибочно интерпретирует отсутствующий контекст как 32-битный и не может отобразить стек вызовов на Windows 7}
    \label{fig:windbg-vol}
\end{center}
\end{figure}

\newpage
\section*{PVpanic и QEMU Guest Agent}

PVpanic -- виртуальное устройство на шине ISA, основным предназначением которого является генерация события в QEMU при аварийном завершении работы гостевой ОС.

QEMU Guest Agent -- специальная служба внутри гостевой ОС, которая позволяет со стороны гипервизора производить различные операции, связанные с управлением гостевой ОС.

В 2017 году в драйвер PVpanic для Windows был добавлен ioctl-интерфейс, который позволяет пользовательскому приложению получать заголовок полного дампа памяти, с помощью вызова KeInitializeCrashDumpHeader (функция ядра Windows, сохраняющая заголовок полного дампа памяти, доступная драйверам\cite{kicdh}). По замыслу автора, этим приложением должен был быть QEMU Guest Agent\cite{qgaioctl}. QEMU Guest Agent позволяет со стороны гипервизора производить различные действия внутри виртуальной машины. Для работы данного метода требовалось добавить возможность делать со стороны хоста ioctl-запросы к файлам в гостевой ОС. Но сообщество разработчиков QEMU не приняло соответствующий патч, объяснив это тем, что добавляемая логика работы слишком сложна и сильно зависит от типа гостевой ОС.
Таким образом, этот метод так и остался не до конца реализованным.

\chapter{Описание метода}

Cобрать заголовок на хосте из содержимого памяти и регистров сложно по нескольким причинам:

\begin{itemize}
\item Неизвестно, где находится начало таблицы страниц для системного контекста. Для этого можно было бы использовать доступное гипервизору содержимое регистров CR3. Но возможна ситуация, при которой на всех виртуальных процессорах происходит исполнение пользовательских приложений, а в последних версиях современных ОС для x86 большая часть системной памяти не отображается в адресное пространство пользовательских процессов.
\item Поиск KdDebuggerDataBlock по сигнатуре затруднен, поскольку эта структура зашифрована в памяти новых версий Windows\cite{kdbgenc}.
\item Поиск начала образа ядра Windows в памяти тоже нетривиален, поскольку при загрузке системы он принимает случайное значение благодаря технологии KASLR (Kernel Address Space Layout Randomizing -- рандомизация размещения адресного пространства ядра), которая используется в новых версиях Windows.
\end{itemize}

Руководствуясь этими фактами, а так же тем, что Windows предоставляет драйверам специальный интерфейс для получения заголовка дампа, решено разработать драйвер для гостевой системы, который сохранял бы заголовок в память и передавал его в гипервизор.

\section*{KeInitializeCrashDumpHeader}

KeInitializeCrashDumpHeader -- частично документированная функция, которая может быть вызвана драйвером для получения заголовка дампа\cite{kicdh}.
В соответствии с официальной документацией, функция позволяет получить заголовок, который будет корректным всё время жизни системы, хотя и обладает следующими ограничениями:

\begin{itemize}
\item При изменении количества физической памяти заголовок должен быть получен снова.
\item Полученный таким образом заголовок не содержит данных о возникшей ошибке (поле BugcheckData).
\end{itemize}

Также, согласно документации, начиная с Windows 8, адрес корня таблицы страниц (DirectoryTableBase) в полученном заголовке всегда соответствует системному контексту, но для более ранних версий контекст будет совпадать с контекстом текущего процесса, в том числе может быть пользовательским, что затем может помешать отладчику осуществлять доступ к системным структурам по виртуальным адресам.

Кроме того, путем замены заголовка в сохраненном системой дампе (например после искусственно вызванного BSoD) на заголовок, полученный драйвером, и анализа такого модифицированного дампа обнаруживаются ещё несколько несоответствий:

\begin{itemize}
\item Не заполнено поле RequiredDumpSpace.
\item Не заполнено поле Context (содержимое регистров одного из процессоров).
\item Поле PfnDatabase имеет неверное значение.
\end{itemize}

Выяснилось, что нулевое значение RequiredDumpSpace не позволяет WinDbg правильно анализировать память. Степень заполнения структуры Context не влияет на результат, но влияет значение аналогичных структур в самой памяти -- это не позволяет WinDbg отобразить значения регистров и стека вызовов. Влияние значение PfnDatabase вообще никак не проявляется.

Как уже было сказанно выше, структура KdDebuggerDataBlock содержит поля, дублирующие поля в заголовке, и это можно использовать для их исправления.
Способы восстановления полей заголовка собраны в соответствующей таблице:

\begin{table}[h]
\begin{tabular}{|c|c|c|}
\hline
Поле заголовка & Дамп на BSoD & Дамп живой системы \\
\hline
BugcheckData & \begin{minipage}{5.5cm}\begin{center}~\\Можно взять по адресу из поля KiBugcheckData внутри KdDebuggerDataBlock\\~\end{center}\end{minipage}& \begin{minipage}{5.5cm}\begin{center}~\\Использовать код 0x161 (LIVE{\_}SYSTEM{\_}DUMP)\\~\end{center}\end{minipage}\\
\hline
PfnDatabase &\multicolumn{2}{c|}{\begin{minipage}{11cm}\begin{center}~\\Можно взять из поля MmPfnDatabase внутри структуры KdDebuggerDataBlock\\~\end{center}\end{minipage}}\\
\hline
RequiredDumpSpace & \multicolumn{2}{c|}{\begin{minipage}{11cm}\begin{center}~\\Можно вычислить на основе информации о сохраненных регионах физической памяти\\~\end{center}\end{minipage}}\\
\hline
Context & \multicolumn{2}{c|}{\begin{minipage}{11cm}\begin{center}~\\Поле можно не заполнять, отладчик получает данные о значениях регистров каждого процессора из соответствующей ему структуры PRCB\\~\end{center}\end{minipage}}\\
\hline
\end{tabular}
\caption{Восстановление полей заголовка}
\end{table}

\section*{Транспорт для заголовка}

После того как заголовок получен, он должен быть передан в хост. Для этого можно использовать виртуальное устройство VMCoreInfo, которое изначально предназначено для передачи вспомогательных данных о ядре при создании дампов гостевой ОС Linux. VMCoreInfo является надстройкой над другим виртуальным аппаратным интерфейсом, который называется FwCfg и будет подробно расмотрен далее.

\section*{FwCfg}

FwCfg -- виртуальный аппаратный интерфейс, предоставляемый QEMU, позволяющий гостевому ПО обмениваться данными с хостом. С точки зрения гостевого ПО, представляет из себя устройство с портами ввода-вывода с номерами в диапазоне 0x510--0x51B. Предоставляет доступ к массиву записей (entry), которые являются просто блоками данных, и которым сопоставлено строковое имя. В зависимости от настроек, определяемых при создании каждой записи, может быть осуществлен доступ из гостевой ОС для чтения или модификации данных.

\section*{VMCoreInfo}

VMCoreInfo -- виртуальное устройство, доступ к которому осуществляется через запись FwCfg под названием \texttt{"etc/vmcoreinfo"}. Изначально создано для добавления информации о ядре Linux. При создании дампа в ELF-формате из QEMU эти данные автоматически присоединятся к нему. Обработка VMCoreInfo уже является частью функциональности создания дампов в формате ELF в QEMU, поэтому легко адаптируется для решаемой задачи. Также хорошим побочным эффектом является появление возможности создавать ELF-дампы, данных в которых потенциально достаточно их для конвертации в понятный WinDbg формат каким-либо внешним по отношению к QEMU инструментом.

\section*{Взаимодействие драйвера и VMCoreInfo}

Для того чтобы осуществлять запись или чтение из любой FwCfg-записи, в частности VMCoreInfo, драйвер использует порты ввода-вывода в диапазоне 0x510--0x51B.

Чтение данных из записи производится по следующему алгоритму:
\begin{enumerate}
\item В порт 0x510 отправляется номер записи, данные которой нужно прочитать.
\item Из порта 0x511 побайтно считываются данные.
\end{enumerate}

Чтобы записать данные в VMCoreInfo, нужно сначала эту найти запись по её названию (в данном случае -- \texttt{"etc/vmcoreinfo"}), а также проверить что в данной версии FwCfg возможна передача данных из гостя в хост:

\begin{enumerate}
\item Считывается запись c номером 0x19 длиной 4 байта -- это суммарное количество записей.
\item Считываются все записи и находится номер с подходящим названием.
\item Проверяется значение восьми байт, считанных из портов 0x514--0x51B, они должны иметь значение 0x51454d5520434647 -- это означает, что устройством FwCfg поддерживается DMA-подобный (Direct Memory Access -- прямой доступ к памяти) интерфейс записи.
\end{enumerate}

В случае VMCoreInfo передается упакованная структура следующего вида:

\begin{verbatim}
struct FWCfgVMCoreInfo {
    uint16_t host_format;
    uint16_t guest_format;
    uint32_t size;
    uint64_t paddr;
} QEMU_PACKED;
\end{verbatim}

Поля host{\_}format и guest{\_}format должны быть равны соответственно 0 и 1, size -- размер передаваемых данных, paddr -- их физический адрес.

Отправка данных осуществляется через DMA-подобный интерфейс:

\begin{enumerate}
\item В порты 0x514--0x51B записывается физический адрес структуры FWCfgDmaAccess, содержащей физический адрес записываемых данных, их длину, а также номер записи и управляющие биты.
\item Происходит проверка управляющих битов, если они все равны 0, то передача произошла успешно.
\end{enumerate}

После этого, QEMU будут доступны данные по адресу paddr. QEMU интерпретирует их как секцию ELF Note (\picref{fig:elfnote}), которая состоит из названия (в данном случае \texttt{"VMCOREINFO"}) и содержимого -- заголовка дампа\cite{elfspec}. Если структура секции корректна, то она становится доступна подсистеме создания дампов, и при создании ELF-дампа автоматически присоединяется к нему.

\begin{figure}[h]
\begin{center}
    \includegraphics[width=5cm]{note.png}
    \caption{Структура секции ELF Note}
    \label{fig:elfnote}
\end{center}
\end{figure}

Схема связи между структурами, участвующими в передаче заголовка показана на \picref{fig:sc1}.

\begin{figure}[h]
\begin{center}
    \includegraphics[width=1\textwidth]{vmci_scheme1.png}
    \caption{Упрощенная схема связи между структурами}
    \label{fig:sc1}
\end{center}
\end{figure}

\newpage
\section*{Команда dump-guest-memory в QEMU Monitor}

QEMU предоставляет пользователю и программам специальный интерфейс управления собой -- монитор, поддерживающий два протокола: HMP (Human Monitor Protocol), предназначенный для взаимодействия QEMU и пользователя через консоль, и QMP (QEMU Machine Protocol), основанный на формате JSON и позволяющим другим приложениям управлять работой QEMU. Оба эти механизма управления поддерживают команду dump-guest-memory, которая создает дамп гостевой памяти в указанном формате, например в формате ELF. Как уже было сказано выше, во время работы этой команды QEMU выгружает данные VMCoreInfo из соответствующего виртуального устройства, что делает работу с ними достаточно удобной. Кроме того, код QEMU содержит специальные средства для работы с физической и виртуальной памятью гостевой системы, а также для работы с регистрами виртуальных процессоров. Принимая во внимание эти факторы, а так же то, что часть процедуры создания дампа общая для всех форматов, решено не делегировать создание дампа в формате DMP внешнему инструменту (хотя такая возможность по-прежнему остается), а добавить возможность сохранения в формате DMP в команду dump-guest-memory.

\section*{Регистровый контекст}

В процессе анализа отладочного дампа значения значения регистров важны сами по себе, кроме того, их значения необходимы для корректного восстановления стека вызовов.

В файле \texttt{wdm.h}, который поставляется как часть WDK, есть определение структуры под названием CONTEXT. После сравнения этого определения, значений регистров из QEMU и поля Context из сохраненного Windows дампа, становится понятным, что поле Context содержит экpемпляр именно этой структуры. Но поскольку на современных системах количество процессоров больше одного, регистровые контексты всех процессоров не могут поместиться в заголовке дампа (там выделено место ровно под один экземпляр контекста).

В структуре PRCB содержится поле ContextFrame. В сохраненном Windows полном дампе по адресу из этого поля содержится регистровый контекст процессора, соответствующего этому экземпляру структуры PRCB. Если эти структуры заполнены нулевыми значениями, то WinDbg не может восстановить контекст. Кроме того, в соответствии с описанием, структура контеста содержит поле флагов, один из которых обозначает, что контекст -- 64-разрядный, поэтому, когда структура не заполнена, отладчик выводит сообщение, что доступен только 32-битный контекст (\picref{fig:ctx1}). После заполнения структур контекста эти проблемы не возникают (\picref{fig:ctx2}). Поэтому можно утверждать, что WinDbg берет содержимое регистров именно из этих структур.

\begin{figure}[h]
\begin{center}
    \captionsetup{justification=centering}
    \includegraphics[width=1\textwidth]{ctx1.png}
    \caption{WinDbg определяет отсутствующий регистровый контекст как 32-битный и устанавливает режим x86. Нельзя увидеть ни стек, ни содержимое регистров.}
    \label{fig:ctx1}
\end{center}
\end{figure}

\begin{figure}[h]
\begin{center}
    \captionsetup{justification=centering}
    \includegraphics[width=1\textwidth]{ctx2.png}
    \caption{Отладчик после загрузки регистрового контекста может определить стек вызовов, исполняющуюся инструкцию, исполняемый образ и с помощью отладочной информации вывести названия функций.}
    \label{fig:ctx2}
\end{center}
\end{figure}

\newpage
Таким образом, чтобы WinDbg cмог получить актуальные значения регистров, они должны быть сохранены в соответствующих структурах внутри дампа памяти. Независимая от версии Windows процедура восстановления регистровых контекстов может выглядеть так:

\begin{itemize}
\item Загрузка адресов PRCB всех процессоров из массива $KdDebuggerDataBlock \! \rightarrow \! KiProcessorBlock$.
\item Нахождение адресов структур контекстов ContextFrame по их смещению внутри PRCB на основе значения поля $KdDebuggerDataBlock \! \rightarrow \! OffsetPrcbContext$.
\item Заполнение контекстов, находящихся по этим адресам, значениями регистров.
\end{itemize}

\section*{KiBugcheckData}

BugcheckData автоматически сохраняется при BSoD и эти данные можно просто скопировать в заголовок. Но оказывается, что при создании дампа живой системы недостаточно записать BugcheckData в заголовок. Для того чтобы отладчик мог воспользоваться этими данными, они также должны быть сохранены в $KdDebuggerDataBlock \! \rightarrow \! KiBugcheckData$.

\section*{Алгоритм работы компонента QEMU}

После того как заголовок доступен гипервизору, QEMU может приступать к созданию дампа.

\begin{enumerate}
    \item $\!\!\!\!{^*}$ Виртуальная машина ставится на паузу.
    \item $\!\!\!\!{^*}$ Производится синхронизация c KVM.
    \item Значение поля RequiredDumpSpace вычисляется как сумма размеров непрерывных регионов физической памяти, присутствующих в дампе, и подставляется в заголовок.
    \item Значение поля DirectoryTableBase из заголовка используется как значение регистра CR3 при дальнейшем доступе к виртуальному адресному пространству гостевой ОС из QEMU.
    \item Адрес KdDebuggerDataBlock принимается равным адресу из соответствующего поля заголовка.
    \item Значения поля PfnDatabase подставляется из поля $KdDebuggerDataBlock \! \rightarrow \! MmPfnDatabase$.
    \item Значения полей BugcheckData (код и параметры ошибки)
    \begin{itemize}
        \item В случае дампа в момент аварийного завершения подставляются из структуры по адресу $KdDebuggerDataBlock \! \rightarrow \! KiBugcheckData$.
        \item Код 0x161 (LIVE{\_}SYSTEM{\_DUMP}) и нулевые параметры ошибки подставляются в заголовок и в структуру по адресу $KdDebuggerDataBlock \! \rightarrow \! KiBugcheckData$ в случае дампа живой системы.
    \end{itemize}
    \item Регистровый контекст сохраняется по адресу из поля $KdDebuggerDataBlock \! \rightarrow \! KiProcessorBlock[i] \! \rightarrow \! ContextFrame$, где i -- номер процессора, на основе значений регистров из QEMU (на этом этапе они уже имеют согласованное с KVM значение).
    \item Заголовок записывается в файл.
    \item Регионы физической памяти гостевой ОС на основе их описания в заголовке записываются в файл.
    \item $\!\!\!\!{^*}$ Виртуальная машина продолжает работу.
\end{enumerate}

Программная реализация помеченных {*} пунктов не требуется, так как эта часть общая для всех форматов и уже реализована в QEMU.

\section*{KdDebuggerDataBlock в Windows 8 и более новых\\версиях}

Практика показывает, что KdDebuggerDataBlock, начиная с Windows 8, может быть зашифрован системой на этапе ее загрузки и быть недоступным во время работы (\picref{fig:kd1}), а расшифровывается только во время аварийного завершения (\picref{fig:kd2}, сделанный для той же самой системы). Поэтому описанный выше метод будет работать в случае BSoD на любой из рассматриваемых версий Windows, но для снятия дампа с живой системы алгоритмы работы как драйвера, так и гипервизора должны быть дополнены с учетом этого факта. Поскольку метод основан на работе гостевого драйвера, то представляется наиболее простым получать расшифрованный KdDebuggerDataBlock так же с помощью драйвера.

\section*{KdDebuggerDataBlock и Small Memory Dump}

Наряду с полным дампом памяти, достаточно понятной является структура малого дампа памяти (Small Memory Dump). Windows создает дамп в этом формате после BSoD при настройках по умолчанию. Такой дамп содержит следующие данные:

\begin{itemize}
    \item Структура BugcheckData
    \item Данные о процессе, в котором возникла ошибка (структура EPROCESS)
    \item Информация о потоке, в котором возникла ошибка (структура ETHREAD)
    \item Контекст процессора (структура PRCB), на котором возникла ошибка
    \item Список загруженных модулей
    \item Структура KdDebuggerDataBlock
\end{itemize}

В отличие от полного дампа памяти, KdDebuggerDataBlock хранится в файле дампа по записанному в его заголовке смещению, поэтому страничное преобразвание не требуется. Таким образом, имея малый дамп, можно с его помощью создать полный дамп памяти.

\begin{figure}[h!]
\begin{center}
    \captionsetup{justification=centering}
    \includegraphics[width=9cm]{s1337.png}
    \caption{Схема связи между элементами дампа на этапе их выгрузки из гостевой памяти}
    \label{fig:scheme22}
\end{center}
\end{figure}

\section*{KeCapturePersistentThreadState}

KeCapturePersistentThreadState -- недокументированная функция ядра Windows. Драйвер может использовать ее для сохранения в памяти Small Memory Dump\cite{kcpts}. KdDebuggerDataBlock внутри такого дампа будет расшифрован.

Гостевой драйвер может передавать в гипервизор не только адрес оригинального KdDebuggerDataBlock (который может быть зашифрован), который система кладет в заголовок дампа, но и адрес его расшифрованной версии, которая будет храниться в памяти драйвера.

Для того чтобы гипервизор мог воспользоваться этой возможностью, он должен проверить сигнатуру KdDebuggerDataBlock, адрес которого лежит в своём обычном месте в заголовке, и, если сигнатура не совпадает, использовать KdDebuggerDataBlock, адрес которого может быть передан драйвером через одно из неиспользуемых полей заголовка, например, BugcheckParameter1, поскольку это поле всё равно имеет нулевое значение и должно быть заполнено гипервизором.

Именно такой подход для передачи и обработки запасного KdDebuggerDataBlock и реализован в данной работе в гостевом драйвере и QEMU (\picref{fig:scheme22}).

\begin{figure}[h]
\begin{center}
    \captionsetup{justification=centering}
    \includegraphics[width=1\textwidth]{kd2.png}
    \caption{KdDebuggerDataBlock зашифрован на Windows 10 в дампе, снятом во время работы системы}
    \label{fig:kd1}
\end{center}
\end{figure}

\begin{figure}[h]
\begin{center}
    \captionsetup{justification=centering}
    \includegraphics[width=1\textwidth]{kd1.png}
    \caption{KdDebuggerDataBlock расшифрован на Windows 10 в дампе после BSoD. Можно заметить, что он находится по тому же адресу, что и на \picref{fig:kd1}}
    \label{fig:kd2}
\end{center}
\end{figure}

\chapter{Заключение}

В работе проведено исследование структуры полного дампа памяти ОС Windows. Для 64-разрядной ОС Windows на основе ядра с номером 6.1 или выше представлен метод получения этих данных, который не зависит от конкретной версии Windows и, возможно, будет работать и с появлением новых версий. Разработаны методы передачи необходимой информации об ОС в гипервизор и создания с ее помощью полного дампа памяти Windows. Таким образом выполнена задача по исследованию необходимых для отладочного дампа Windows данных и задача по разработке метода создания дампов со стороны гипервизора. Достигнута цель по созданию метода решения проблем в ОС Windows, работающей под управлением гипервизора QEMU/KVM, поскольку полученный таким способом дамп содержит всю требуемую отладчиком информацию о системе, который позволяет анализировать виртуальную память, регистры, стек вызовов и другие данные о системных и пользовательских процессах, присутствующих на системе в момент аварийного завершения или в момент создания дампа в случае дампа живой системы (может использоваться для анализа зависаний).

Методы сбора и передачи данных реализованы в виде драйвера, непосредственно собирающего необходимую для создания дампа информацию из гостевой системы, и патча для гипервизора QEMU, добавляющего команде dump-guest-memory новую опцию -w, которая позволяет напрямую, без конвертации, создавать дампы в формате DMP (может быть проанализирован WinDbg или kd.exe), если внутри гостевой системы работает драйвер. Кроме того, дампы в формате ELF также будут содержать всю необходимую для дальнейшей конвертации в формат DMP информацию.

Код драйвера одобрен сообществом разработчиков проекта KVM Windows Guest Drivers и включен в проект. Код компонента QEMU добавлен в один из продуктов компании Virtuozzo -- Virtuozzo Hypervisor, а также находится в процессе принятия в основную ветку проекта QEMU.

\chapter{Возможные направления дальнейшего развития проекта}

Вариантами возможного продолжения данной работы являются следующие направления:
\begin{itemize}
\item Поскольку одним из вариантов использования технологии виртуализации является отказ от устаревшей аппаратной платформы и перенос ПО в соответствующую виртуализованную среду, следует рассмотреть добавление возможности работы представленного механизма с 32-разрядными версиями Windows.
\item Существует способ динамического увеличения размера доступной виртуальной машине памяти под названием RAM hot-plug, который заключается в динамическом добавлении виртуальных модулей памяти. В настоящее время драйвер не создает новый заголовок в такой ситуации, но возможно сделать обработку этого случая с помощью стандартных событий.
\item Одним из наиболее популярных при запуске виртуальных машин с операционной системой Windows является проприентарный гипервизор Hyper-V от корпорации Microsoft.\\Для того чтобы сделать дамп памяти гостевой Windows, работающей под Microsoft Hyper-V, можно использовать одну из утилит Sysinternals Suite -- LiveKd\cite{livekd-hv}. Эта программа позволяет по идентификатору виртуальной машины, работающей под управлением Hyper-V, сделать полный дамп памяти этой виртуальной машины и сохранить его на файловой системе хостовой операционной системы. Примечательно, что для работы этого механизма не требуется делать никаких настроек внутри виртуальной машины, в том числе не требуется устанавливать дополнительные драйверы.\\Таким образом, одним из возможных направлений дальнейшей работы является подробное исследование работы этого инструмента и попытка реализовать аналогичный механизм как компонент QEMU/KVM.
\newpage
\item В рассмотреной в работе схеме заголовок полного дампа памяти может быть получен как одна из секций дампа в формате ELF. На данный момент, такие утилиты как Volatility при попытке конвертации дампа из ELF формата не используют данные VMCOREINFO. Возможно добавить такой сценарий работы в Volatility, что позволило бы Volatility правильно производить конвертацию.
\end{itemize}

\addcontentsline{toc}{chapter}{\bibname}
\printbibliography

\end{document}
