\documentclass{mipt-thesis-bs}
\usepackage{listings}
\title{Разработка методов отладки в реальном времени и отложенного анализа проблем в гостевой операционной системе Microsoft Windows под гипервизором QEMU/KVM}
\author{Прутьянов В.\,В.}
\supervisor{Каган Р.\,В.}
\groupnum{416}
\faculty{Факультет радиотехники и кибернетики}
\department{Кафедра теоретической и прикладной информатики}

\begin{document}
\titlecontents

\chapter{Введение}

В настоящее время большая часть рабочей серверной нагрузки выполняется с помощью различных технологий виртуализации. Виртуализация позволяет на основе одной физической системы запускать множество независимых друг от друга изолированных сред, между которыми могут быть распределены вычислительные ресурсы физической системы.

Одним из видов виртуализации является гипервизорная виртуализация. В этом случае, специальное ПО, называемое гипервизором, который может быть как частью операционной системы, так и непосредственно выполняться на физическом оборудовании, позволяет разделить физические ресурсы между изолированными средами, которые называются виртуальными машинами. Тогда физическое оборудование, на котором запущен гипервизор называется хостом, а виртуальные машины называются гостями.

В настоящее время в качестве хостовой ОС на серверах часто используется ОС Linux. Один из компонентов этой системы -- гипервизор KVM, который работает в связке с эмулятором QEMU. Операционные системы, работающие внутри хоста и гостей, могут быть различными в случае гипервизорной виртуализации, поэтому внутри виртуальной машины под управлением QEMU/KVM может быть запущена почти любая ОС, в том числе Linux и Microsoft Windows.

Виртуализация, в частности гипервизорная, является достаточно сложной процедурой, поэтому при работе гостевой ОС могут возникать проблемы, такие как зависания или аварийные завершения. Эти проблемы могут быть вызваны как ошибками в работе гостевой ОС, так и ошибками, связанными с неправильной работой гипервизора. Существуют два метода выяснения причин подобных проблем: отладка ядра гостевой ОС и анализ снимков состояния виртуальной машины, называемых дампами.

Для гостевой Linux оба метода удобны и не представляют большой сложности при работе с QEMU:

\begin{itemize}
\item QEMU предоставляет интерфейс для отладчика GDB, через который можно отлаживать ядро гостевой ОС Linux как обычную программу.
\item QEMU позволяет сделать снимок состояния виртуальной машины, называемый дампом , в формате ELF, который затем можно анализировать утилитой crash
\end{itemize}

Аналоги этих методов существуют и для случая, когда виртуальная машина работает под управлением Windows:

\begin{itemize}
\item Подключение через виртуальный последовательный порт или Ethernet отладчика WinDbg
\item Создание отладочного дампа в формате DMP, понятном отладчику WinDbg, и его анализ.
\end{itemize}

Поскольку, как правило, администрируют хостовые системы и гостевые системы разные люди, наиболее предпочтительным для любой гостевой ОС является создание отладочных дампов, так как это требует наименьшее количество действий (или вовсе не требует) от пользователя виртуальной машины, который может не обладать желанием или соответствующей квалификацией для настройки гостевой ОС в режиме отладки. Также, метод создания и анализа отладочных дампов не требует специального воспроизведения условий, приводящих к ошибке. Таким образом, возможность снятия отладочных дампов имеет наибольшую ценность для разработчиков ПО виртуализации.

Метод, связанный с анализом дампов, в случае гостевой ОС Windows под управлением QEMU имеет существенные проблемы:

\begin{itemize}
\item QEMU не имеет встроенного средства для создания дампов памяти в формате DMP. Для получения дампа в этом формате в произвольный момент времени на живой системе можно попытаться создать дамп в формате ELF и конвертировать его в формат DMP, но это не всегда возможно, особенно на последних версиях Windows.
\item В случае аварийного завершения Windows автоматически сохраняет дамп на диске, что сопровождается так называемым BSoD (англ. Blue Screen of Death - синий экран смерти), но для этого, во-первых, система должна быть настроена на создание полного дампа памяти, который наиболее полно отражает состояние системы (по умолчанию же сохраняется практически бесполезный малый дамп памяти), а во-вторых, дамп может быть не создан, например, если не хватает свободного места на диске, или по другим причинам\cite{nodump}.
\end{itemize}

Таким образом, одним из важных сценариев является создание дампа в момент возникновения BSoD, когда гостевая система по каким-либо причинам не способна это сделать. Поэтому представляется актуальным разработка метода создания отладочного дампа гостевой Windows в формате, понятном отладчику WinDbg, как в случае живой системы, так и на этапе аварийного завершения.

На данный момент выпущено много различных версии Windows, из которых сейчас действительно популярны серверные системы начиная с Windows Server 2008 R2 и десктопные системы начиная с Windows 7, которые работают на основе одного ядра Windows версии 6.1. Также, наиболее популярными сейчас являются 64-битные версии, поэтому в работе будут рассмотрены 64-битные версии Windows на основе этой версии ядра и старше.

В работе будет рассмотрено, из чего состоит полный дамп памяти Windows, какие данные требуются для его создания, существующие методы их сбора и предложен подход для создания дампа во время BSoD, а также расширение этого подхода для работы на живой системе.

\chapter{Постановка задачи}

\begin{itemize}
\item Исследовать, какие данные необходимы для создания полного дампа памяти и как они могут быть получены.
\item Разработать метод снятия полных дампов памяти в формате DMP с 64-разрядной гостевой ОС Windows с версией ядра $\geqslant$ 6.1, работающей под управлением QEMU/KVM, в момент аварийного завершения.
\item Добавить возможность снятия дампов с живой системы.
\item Программно реализовать эти методы.
\end{itemize}

\chapter{Основные используемые технологии и инструменты}

\section*{QEMU}

QEMU - эмулятор аппаратного обеспечения с открытым исходным кодом, который позволяет эмулировать x86-совместимый процессор и периферию и запускать на нем соответствующее ПО. Также существует возможность ускорения работы с помощью KVM, Xen, Apple Hypervisor Framework или других ускорителей.

\section*{KVM}

KVM (Kernel-based Virtual Machine) - ПО обеспечивающее виртуализацию на платформе x86 в ОС Linux. Для работы требуется наличие технологии аппаратной поддержки виртуализации, такой как Intel VT-x или AMD-V.

\section*{WinDbg}
% FIXME %
Тут про ВинДбг 

\chapter{Полный дамп памяти}

В ОС Windows существует несколько различных форматов дампов, набор которых различается в зависимости от версии Windows. В данной работе рассматривается полный дамп памяти (англ. complete memory dump), который доступен во всех рассматриваемых версиях Windows. Этот тип дампа содержит наибольшее количество информации и позволяет отладчику анализировать весь объем используемой системой физической памяти.

Структура полного дампа (рис. 1) представляет из себя несколько крупных частей:

\begin{itemize}
    \item Заголовок длиной в 2 страницы
    \item Снимки непрерывных регионов физической памяти. Их количество, начальные адреса и длины хранятся в заголовке.
\end{itemize}

\begin{figure}[h]
\begin{center}
    \includegraphics[width=5cm]{dmp_scheme1.png}
    \caption{Схема полного дампа}
\end{center}
\end{figure}

Кроме информации о регионах физической памяти, заголовок дампа содержит другие необходимые для работы отладчика поля, в том числе:

\begin{itemize}
    \item BugcheckData -- код и 4 параметра, которые описывают причину аварийного завершения системы (их можно увидеть на синем экране во время падения). WinDbg анализирует эти значения и выводит примерную причину падения (рис. 2).
    \item RequiredDumpSpace -- суммарный размер дампа в байтах
    \item DirectoryTableBase -- физический адрес начала таблицы страниц, на основе которой отладчик будет производить страничное преобразование для доступа к данным по виртуальным адресам
    \item PfnDatabase -- виртуальный адрес базы данных PFN-номеров
    \item PsLoadedModuleList -- виртуальный адрес списка загруженных исполняемых модулей
    \item KdDebuggerDataBlock -- виртуальный адрес специальной структуры ядра Windows, хранящей необходимую для работы отладчика информацию.
    \item MinorVersion, MajorVersion - два поля, вместе определяющие версию Windows
\end{itemize}

\begin{figure}[h]
\begin{center}
    \includegraphics{ss1.png}
    \caption{Bugcheck-анализ в WinDbg}
\end{center}
\end{figure}

Структура KdDebuggerDataBlock содержит указатели на другие важные структуры данных в ядре и смещения внутри них, например:
\begin{itemize}
\item KiProcessorBlock -- указатель на массив указателей на PRCB (processor control block) -- структуры, в которые ОС сохраняет данные по каждому используемому процессору.
\item OffsetPrcbContext -- в соответствии с названием, смещение структуры внутри PRCB, в которую ОС сохраняет регистровый контекст при аварийном завершении. 
\item KiBugcheckData -- указатель на данные о падении, которые автоматически сохраняются в это поле системой во время аварийного завершения. По сути, дублирует поле с похожим названием из заголовка.
\end{itemize}

BugecheckData это не единственно поле, которое присутствует и в структуре заголовка и в структуре KdDebuggerDataBlock.

В отличие от заголовка дампа, структуру содержимого KdDebuggerDataBlock можно увидеть в файле wdbgexts.h, который поставляется вместе с WinDbg. Эта структура обладает таким свойством, что с появлением новой версии Windows в ее конец только добавляются новые поля, а уже существующие остаются по тем же смещениям.

Можно заметить, что если такие поля заголовка как RequiredDumpSpace при определенных условиях можно вычислить и заполнить на основе данных из гипервизора, то такие поля как KdDebuggerDataBlock и PsLoadedModuleList известны только гостевой ОС.

Таким образом, для получения правильного дампа, нужно собрать вместе корректный заголовок и снимки непрерывных участков физической памяти. Снимки несложно сделать из QEMU, поскольку он имеет удобный доступ к физической памяти виртуальной машины. Получение же заголовка, как можно было понять из описания его полей, является нетривиальной задачей.

\chapter{Обзор существующих решений}

Рассмотрим существующие решения проблемы получения заголовка и недостатки этих решений.

\section*{Volatility}

Volatility - инструмент с открытым исходным кодом для анализа памяти различных операционных систем. Содержит расширение под названием raw2dmp, которое позволяет конвертировать сырой снимок памяти в формат, который может быть прочитан WinDbg.

Процедура получения дампа помощью Volatility состоит в том, чтобы с помощью QEMU собрать дамп в формате ELF, а затем произвести конвертацию в raw-дамп, который содержит только только память виртуальной машины, после чего конвертировать его в формат DMP c помощью расширения raw2dmp.

Алгоритм работы расширения raw2dmp состоит в последовательном сканировании памяти и нахождении по сигнатуре специального блока данных для отладчика KdDebuggerDataBlock, который затем помогает создать корректный заголовок дампа.

На данный момент этот метод имеет следующие проблемы:

\begin{itemize}
    \item После конвертации raw-дамп не хранит в себе информации о содержимом регистров виртуальных процессоров, поэтому после преобразования в дамп для WinDbg, содержимое регистров будет взято отладчиком из сохраненного системой контекста и будет неактуальным. В частности, это помешает восстановлению стеков вызовов.
    \item Начиная с Windows 8, система может на этапе загрузки зашифровать область памяти, в которой находится KdDebuggerDataBlock, поэтому его невозможно будет найти простым сканированием памяти и сравнением сигнатур.
\end{itemize}

\section*{PVpanic}

PVpanic - виртуальное устройство на шине ISA, основным предназначением которого является генерация события в QEMU при аварийном завершении работы гостевой ОС.

В 2017 году в драйвер PVpanic для Windows был добавлен ioctl-интерфейс, который позволяет пользовательскому приложению получать заголовок полного дампа памяти, с помощью вызова KeInitializeCrashDumpHeader (функция ядра Windows, сохраняющая заголовок полного дампа памяти, доступная драйверам). По замыслу автора, этим приложением должен был быть QEMU Guest Agent -- специальная служба внутри гостевой ОС, которая помогает инструментам хоста управлять виртуальной машиной. QEMU Guest Agent позволяет из хоста обращаться к файлам в гостевой ОС для записи и чтения, а для работы данного метода требовалось добавить возможность делать к файлам ioctl-запросы. Но сообщество разработчиков QEMU не приняло соответствующий патч, объяснив это тем, что добавляемая логика работы слишком сильно зависит от типа гостевой ОС. 
Таким образом, этот метод так и остался не до конца реализованным.

\chapter{Описание метода}

Поскольку собрать заголовок на хосте из содержимого памяти сложно, а Windows предоставляет драйверам специальный интерфейс для получения заголовка дампа, то решено разработать драйвер для гостевой системы, который получал бы заголовок и передавал его в гипервизор для дальнейшей обработки.

\section*{KeInitializeCrashDumpHeader}

KeInitializeCrashDumpHeader - частично документированная функция, которая может быть вызвана драйвером для получения заголовка дампа.
В соответствии с официальной документацией, функция позволяет получить заголовок, который будет корректным всё время жизни системы, хотя и обладает следующими ограничениями:

\begin{itemize}
\item При изменении количества физической памяти заголовок должен быть получен снова
\item Полученный таким образом заголовок не содержит данных о возникшей ошибке (поле BugcheckData)
\end{itemize}

Также, согласно документации начиная с Windows 8, адрес таблицы страниц (DirectoryTableBase) в полученном заголовке всегда соответствует системному контексту, но для более ранних версий контекст будет совпадать с контекстом текущего процесса, в том числе может быть пользовательским, что затем может помешать отладчику осуществлять доступ к системным структурам по виртуальным адресам.

Кроме того, путем замены заголовка в сохраненном системой дампе (например после искусственно вызванного BSoD) на заголовок, полученный драйвером, и анализа такого модифицированного дампа обнаруживаются ещё несколько несоответствий:

\begin{itemize}
\item Не заполнено поле RequiredDumpSpace
\item Не заполнено поле Context (содержимое регистров одного из процессоров)
\item Поле PfnDatabase имеет неверное значение
\end{itemize}

Как уже было сказанно выше, структура KdDebuggerDataBlock содержит поля, дублирующие поля в заголовке, и это можно использовать для их исправления.
Способы восстановления полей заголовка собраны в соответствующей таблице:

\begin{table}[h]
\begin{tabular}{|c|c|c|}
\hline
Поле заголовка & Дамп на BSoD & Дамп живой системы \\
\hline
BugcheckData &\vtop{\hbox{\strut Можно взять из}\hbox{\strut KdDebuggerDataBlock->}\hbox{\strut KiBugcheckData}} &\vtop{\hbox{\strut Использовать код 0x161}\hbox{\strut (LIVE{\_}SYSTEM{\_}DUMP)}} \\
\hline
PfnDatabase &\multicolumn{2}{c|}{\vtop{\hbox{\strut Можно взять из}\hbox{\strut KdDebuggerDataBlock->MmPfnDatabase}}}\\
\hline
RequiredDumpSpace & \multicolumn{2}{c|}{\vtop{\hbox{\strut Можно вычислить на основе информации о}\hbox{\strut сохраненных регионах физической памяти}}}\\
\hline
Context & \multicolumn{2}{c|}{\vtop{\hbox{\strut Поле можно не заполнять, отладчик получает}\hbox{\strut данные о значениях регистров каждого процессора}\hbox{\strut из соответствующей ему структуры PRCB}}}\\
\hline
\end{tabular}
\caption{Восстановление полей заголовка}
\end{table}

\section*{Транспорт для заголовка}

После того как заголовок получен, он должен быть передан в хост. Для этого можно использовать виртуальное устройство VMCoreInfo, которое изначально предназначено для передачи вспомогательных данных о ядре при создании дампов гостевой ОС Linux и является надстройкой над другим виртуальным аппаратным интерфейсом, называемым FwCfg. Обработка VMCoreInfo уже является частью функциональности создания дампов в формате ELF в QEMU, поэтому легко адаптируется для решаемой задачи. Также хорошим побочным эффектом является появление возможности создавать ELF-дампы, данных в которых потенциально достаточно их для конвертации в понятный WinDbg формат каким-либо внешним по отношению к QEMU инструментом.

\section*{FwCfg}

FwCfg - виртуальный аппаратный интерфейс, предоставляемый QEMU, позволяющий гостевому ПО получать данные из хоста. С точки зрения гостевого ПО, представляет из себя устройство с портами ввода-вывода с номерами в диапазоне 0x510-0x51B. Предоставляет доступ к массиву записей (entry), которые могут быть как просто участками памяти, так и файлами на хостовой ОС. В зависимости от настроек, определяемых при создании каждой записи, может быть осуществлен доступ для чтения или модификации данных.

\section*{VMCoreInfo}

VMCoreInfo - виртуальное устройство, доступ к которому осуществляется через одну из записей FwCfg. Изначально создано для добавления гостевой системой информации к дампам в ELF-формате, генерируемым QEMU.

\section*{Взаимодействие драйвера и VMCoreInfo}

Для того, чтобы осуществлять запись или чтение из любой FwCfg-записи, в частности VMCoreInfo, драйвер использует порты ввода-вывода в диапазоне 0x510-0x51B. 

Чтение данных из записи производится по следующему алгоритму:
\begin{enumerate}
\item В порт 0x510 отправляется номер записи, данные которой нужно прочитать
\item Из порта 0x511 побайтно считываются данные
\end{enumerate}

Чтобы записать данные в VMCoreInfo, нужно сначала эту найти запись по её названию (в данном случае - “etc/vmcoreinfo”), а также проверить что в данной версии FwCfg возможна передача данных из гостя в хост:

\begin{enumerate}
\item Считывается запись номер 0x19 длиной 4 байта -- это суммарное количество записей
\item Считываются все записи и находится номер с подходящим названием
\item Проверяется значение восьми байт, считанных из портов 0x514--0x51B, они должны иметь значение 0x51454d5520434647 -- это означает, что поддерживается DMA-подобный интерфейс записи.
\end{enumerate}

В случае VMCoreInfo передается упакованная структура следующего вида:

\begin{lstlisting}
struct FWCfgVMCoreInfo {
    uint16_t host_format;
    uint16_t guest_format;
    uint32_t size;
    uint64_t paddr;
} QEMU_PACKED;
\end{lstlisting}

Поля host{\_}format и guest{\_}format должны быть равны соответственно 0 и 1, size -- размер передаваемых данных, paddr -- их физический адрес. 

Отправка данных осуществляется через DMA-подобный интерфейс:

\begin{enumerate}
\item В порты 0x514-0x51B пишется физический адрес структуры, содержащей физический адрес записываемых данных, их длину, а также номер записи и управляющие биты.
\item Происходит проверка управляющих битов, если они все равны 0, то передача произошла успешно.
\end{enumerate}

После этого, QEMU будут доступны данные по адресу paddr. QEMU интерпретирует их как секцию ELF Note и если структура секции корректна, то она становится доступна подсистеме создания дампов, и при создании ELF-дампа автоматически присоединяется к нему.

\begin{figure}[h]
\begin{center}
    \includegraphics[width=5cm]{note.png}
    \caption{Структура секции ELF Note}
\end{center}
\end{figure}

\section*{Алгоритм работы компонента QEMU}

После того как заголовок доступен гипервизору, QEMU может приступать к созданию дампа.

\begin{enumerate}
    \item Виртуальная машина ставится на паузу.
    \item Производится синхронизация c KVM.
    \item Значение поля RequiredDumpSpace вычисляется как сумма размеров непрерывных регионов физической памяти, присутствующих в дампе, и подставляется в заголовок.
    \item Значение поля DirectoryTableBase из заголовка используются как значение регистра CR3 при дальнейшем доступе к виртуальному адресному пространству гостевой ОС из QEMU.
    \item Значения поля PfnDatabase подставляется из поля\newline KdDebuggerDataBlock->MmPfnDatabase.
    \item Значения полей BugcheckData (код, параметры 1--4)
    \begin{itemize}
        \item Подставляются из полей KdDebuggerDataBlock->KiBugcheckData в случае дампа в момент аварийного завершения.
        \item Код 0x161 (LIVE{\_}SYSTEM{\_DUMP}), нулевые параметры в случае дампа живой системы.
    \end{itemize}
    \item В случае снятия дампа с живой системы,  регистровый контекст заполняется в\newline KdDebuggerDataBlock->KiProcessorBlock[i]->ContextFrame, где i - номер процессора, на основе регистров из QEMU (на этом этапе они уже имеют согласованное с KVM значение).
    \item Заголовок записывается в файл.
    \item Регионы физической памяти гостевой ОС на основе их описания в заголовке записываются в файл.
    \item Виртуальная машина может продолжать работу.
\end{enumerate}

\bibliography{thesis}
\bibliographystyle{plain}

\end{document}